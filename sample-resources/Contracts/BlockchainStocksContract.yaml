apiVersion: v1
kind: ConfigMap
metadata:
  name: dividend
data:
  Dividend.sol: |
    // SPDX-License-Identifier: Unlicense
    pragma solidity ^0.8.9;

    abstract contract Dividend {
        // Event about dividend released (to, amount)
        event DividendReleased(address to, uint256 amount);
        // Mapping between address and the amount of dividend released
        mapping(address => uint256) private _dividendReleased;
        // Total amount of dividend released, used for the releasable calculation
        uint256 private _totalDividendReleased;

        // Move dividend released values from sender to receiver when transfer occurred
        function updateDividendReleasedAfterTransfer(
            address from,
            address to,
            uint256 amount
        ) internal {
            // Tokens already released by the sender
            uint256 _fromReleased = _dividendReleased[from];
            // Tokens amount of the sender
            uint256 _fromBalance = sharesOf(from);
            if (to == address(0)) // Burning
            {
                // How many already released from each token
                // _relativePart = sender already released amount / total tokens balance
                uint256 _releasedPerToken = releasedPerToken(
                    _fromReleased,
                    _fromBalance,
                    amount
                );
                // Relative part removed from 'from'
                // sender_dividends_counter = relative part * left amount
                _dividendReleased[from] = _releasedPerToken * _fromBalance;
            } else if (from == address(0)) // Minting
            {
                // receiver_dividends_counter = 0
                _dividendReleased[to] = _dividendReleased[to];
            }
            // Transferring
            else {
                // How many already released from each token
                // _releasedPerToken = sender already released amount / total tokens balance
                uint256 _releasedPerToken = releasedPerToken(
                    _fromReleased,
                    _fromBalance,
                    amount
                );
                // Relative part removed from 'from'
                // sender_dividends_counter = relative part * left amount
                _dividendReleased[from] = (_releasedPerToken) * _fromBalance;
                // Relative part added to 'to'
                // receiver_dividends_counter = current value + relative part * sent amount
                _dividendReleased[to] =
                    _dividendReleased[to] +
                    ((_releasedPerToken) * amount);
            }
        }

        // Return the already released value for each token
        function releasedPerToken(
            uint256 _fromReleased,
            uint256 _fromBalance,
            uint256 _amountTransfered
        ) internal pure returns (uint256) {
            // dividend released / tokens number + 1 (to overcome down rounding)
            uint256 _releasedPerToken = _fromReleased /
                (_amountTransfered + _fromBalance) +
                1;
            return _releasedPerToken;
        }

        // Release dividends for the requester
        function dividendRelease() public virtual {
            // Get the requester address
            address payable _account = payable(msg.sender);
            // Validate the requester owns shares
            require(
                sharesOf(_account) > 0,
                "DividendSplitter: account has no shares"
            );
            // Get the releasable amount
            uint256 payment = releasableDividends(_account);
            // Validate the payment isn't zero
            require(payment != 0, "DividendSplitter: account is not due payment");

            // _totalReleased is the sum of all values in _released.
            // If "_totalReleased += payment" does not overflow, then "_released[account] += payment" cannot overflow.
            _totalDividendReleased += payment;
            unchecked {
                _dividendReleased[_account] += payment;
            }

            // Send dividends to the account's address
            _account.transfer(payment);
            emit DividendReleased(_account, payment);
        }

        // Get the amount of dividends the account is allowed to pull
        function releasableDividends(
            address account
        ) public view returns (uint256) {
            // The total amount of tokens needs to be split
            // Summarize the current balance + the already pulled amount
            uint256 totalReceived = address(this).balance + totalDividendReleased();
            // return the calculated releasable amount
            return
                _pendingDividendPayment(
                    account,
                    totalReceived,
                    dividendReleased(account)
                );
        }

        // Calculate the amount of dividends the account is allowed to pull
        function _pendingDividendPayment(
            address account,
            uint256 totalReceived,
            uint256 alreadyReleased
        ) internal view returns (uint256) {
            // Total stocks supply
            uint256 _totalShares = totalShares();
            // Shares balance of the account
            uint256 _accountShares = sharesOf(account);
            // Validate shares already minted
            require(_totalShares != 0, "DividendSplitter: No shares yet");
            // Return the pending payment amount
            // all splittable dividends * percent of the account own shares out of the total shares
            uint256 allowedToRelease = (totalReceived * _accountShares) /
                _totalShares;
            // allowed to release some amount
            if (allowedToRelease > alreadyReleased) {
                // Allowed to release - amount already released
                uint256 pendingPayment = allowedToRelease - alreadyReleased;
                return pendingPayment;
            }
            // Disallowed to release any amount (might be less than zero because of up rounding in "updateDividendReleasedAfterTransfer")
            else {
                return 0;
            }
        }

        // Get the amount of dividend already released
        function dividendReleased(address account) public view returns (uint256) {
            return _dividendReleased[account];
        }

        // Get the total amount of dividends already released
        function totalDividendReleased() public view returns (uint256) {
            return _totalDividendReleased;
        }

        // Get the total amount of shares
        function totalShares() public view virtual returns (uint256);

        // Get the total amount of shares for a specific account
        function sharesOf(address account) public view virtual returns (uint256);
    }

---
apiVersion: kontractdeployer.expedio.xyz/v1alpha1
kind: Contract
metadata:
  name: blockchain-stocks-contract
spec:
  contractName: BSP
  networkRef: holesky
  walletRef: dev-wallet
  gasStrategyRef: high-priority-gas
  initParams:
    - "https://example.com/metadata"
    - "0x1234567890abcdef1234567890abcdef12345678"
    - "100000"
    - "1000000000000000000"
  externalModules:
    - "OpenZeppelin/openzeppelin-contracts@v4.8.2"
  localModules:
    - name: dividend
  code: |
    // SPDX-License-Identifier: Unlicense

    // Solidity version 0.8.9 or above
    pragma solidity ^0.8.9;

    // Import modules
    import "lib/openzeppelin-contracts/contracts/token/ERC1155/ERC1155.sol";
    import "lib/openzeppelin-contracts/contracts/access/Ownable.sol";
    import "lib/openzeppelin-contracts/contracts/security/Pausable.sol";
    import "lib/openzeppelin-contracts/contracts/token/ERC1155/extensions/ERC1155Supply.sol";
    import "src/dividend/Dividend.sol";

    // ERC1155 contract which is ownable (controlled by admin), and pausable (both mint and transferring)
    contract BSP is ERC1155, Ownable, Pausable, ERC1155Supply, Dividend {
        /*
            VARIABLES DECLARATION
        */

        // CONTRACT STATE VARIABLES
        // Stock UID
        uint8 public constant Stock = 1;
        // Max stocks supply
        uint256 public maxSupply;
        // Mint price when *not minted by admin*
        uint256 public mintPrice;
        // Address to send mint payments to
        address payable private companyWallet;

        // Identity Tracking
        mapping(address => bool) private whitelist;

        // Constructor to initialize the contract with the following attributes:
        // initURI, initCompanyWallet, initMaxSupply, initMintPrice
        // All of those are changeable later
        constructor(
            string memory initURI,
            address payable initCompanyWallet,
            uint256 initMaxSupply,
            uint256 initMintPrice
        ) ERC1155(initURI) {
            setCompanyWallet(initCompanyWallet);
            setMaxSupply(initMaxSupply);
            setMintPrice(initMintPrice);
        }

        /*
            GETTERS & SETTERS
        */

        // Change the company wallet
        function setCompanyWallet(address payable newCompanyWallet) public onlyOwner {
            companyWallet = newCompanyWallet;
        }

        // Get the company wallet
        function getCompanyWallet() public view returns (address payable) {
            return companyWallet;
        }

        // Change the max supply
        function setMaxSupply(uint256 newMaxSupply) public onlyOwner {
            maxSupply = newMaxSupply;
        }

        // Get the max supply
        function getMaxSupply() public view returns (uint256) {
            return maxSupply;
        }

        // Change the mint price
        function setMintPrice(uint256 newMintPrice) public onlyOwner {
            mintPrice = newMintPrice;
        }

        // Get the mint price
        function getMintPrice() public view returns (uint256) {
            return mintPrice;
        }

        // Mint stocks
        function mintStocks(uint256 amount) public payable {
            require(amount > 0, "Amount must be greater than zero");
            require(totalSupply(Stock) + amount <= maxSupply, "Exceeds max supply");
            require(msg.value >= mintPrice * amount, "Insufficient payment");

            _mint(msg.sender, Stock, amount, "");
            companyWallet.transfer(msg.value);
        }

        // Implement the totalShares function
        function totalShares() public view override returns (uint256) {
            return totalSupply(Stock);
        }

        // Implement the sharesOf function
        function sharesOf(address account) public view override returns (uint256) {
            return balanceOf(account, Stock);
        }

        /*
            IDENTITY TRACKING
        */

        // Add address to whitelist
        function addToWhitelist(address newAddress) public onlyOwner {
            whitelist[newAddress] = true;
        }

        // Check if the given address is in the whitelist or not
        function isInWhitelist(
            address addressToValidate
        ) public view returns (bool) {
            if (whitelist[addressToValidate]) {
                return true;
            } else {
                return false;
            }
        }

        /*
            HOOKS
        */

        // Prehook function running before transfer execution
        function _beforeTokenTransfer(
            address operator,
            address from,
            address to,
            uint256[] memory ids,
            uint256[] memory amounts,
            bytes memory data
        )
            internal
            override(ERC1155, ERC1155Supply)
            whenNotPaused
        {
            super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
            // Block minting and transferring to non-validated addresses
            require(isInWhitelist(to), "Account not in whitelist");
        }

        // Posthook function running after transfer execution
        function _afterTokenTransfer(
            address operator,
            address from,
            address to,
            uint256[] memory ids,
            uint256[] memory amounts,
            bytes memory data
        ) internal override(ERC1155) {
            super._afterTokenTransfer(operator, from, to, ids, amounts, data);
            // Transfer dividend released counter from the sender to the receiver
            updateDividendReleasedAfterTransfer(from, to, amounts[0]);
        }
    }