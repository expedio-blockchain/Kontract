---
apiVersion: kontractdeployer.expedio.xyz/v1alpha1
kind: Contract
metadata:
  name: the-fedz-hook
spec:
  contractName: Counter
  networkRefs:
    - anvil
  walletRef: anvil-wallet
  gasStrategyRef: high-priority-gas
  externalModules:
    - "uniswap/v4-core@3609d81"
    - "uniswap/v4-periphery@f2f68ec"
  code: |
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.24;

    import {BaseHook} from "lib/v4-periphery/src/base/hooks/BaseHook.sol";

    import {Hooks} from "v4-core/libraries/Hooks.sol";
    import {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";
    import {PoolKey} from "v4-core/types/PoolKey.sol";
    import {PoolId, PoolIdLibrary} from "v4-core/types/PoolId.sol";
    import {BalanceDelta} from "v4-core/types/BalanceDelta.sol";
    import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/types/BeforeSwapDelta.sol";

    contract Counter is BaseHook {
        using PoolIdLibrary for PoolKey;

        // NOTE: ---------------------------------------------------------
        // state variables should typically be unique to a pool
        // a single hook contract should be able to service multiple pools
        // ---------------------------------------------------------------

        mapping(PoolId => uint256 count) public beforeSwapCount;
        mapping(PoolId => uint256 count) public afterSwapCount;

        mapping(PoolId => uint256 count) public beforeAddLiquidityCount;
        mapping(PoolId => uint256 count) public beforeRemoveLiquidityCount;

        constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

        function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
            return Hooks.Permissions({
                beforeInitialize: false,
                afterInitialize: false,
                beforeAddLiquidity: true,
                afterAddLiquidity: false,
                beforeRemoveLiquidity: true,
                afterRemoveLiquidity: false,
                beforeSwap: true,
                afterSwap: true,
                beforeDonate: false,
                afterDonate: false,
                beforeSwapReturnDelta: false,
                afterSwapReturnDelta: false,
                afterAddLiquidityReturnDelta: false,
                afterRemoveLiquidityReturnDelta: false
            });
        }

        // -----------------------------------------------
        // NOTE: see IHooks.sol for function documentation
        // -----------------------------------------------

        function beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, bytes calldata)
            external
            override
            returns (bytes4, BeforeSwapDelta, uint24)
        {
            beforeSwapCount[key.toId()]++;
            return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);
        }

        function afterSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)
            external
            override
            returns (bytes4, int128)
        {
            afterSwapCount[key.toId()]++;
            return (BaseHook.afterSwap.selector, 0);
        }

        function beforeAddLiquidity(
            address,
            PoolKey calldata key,
            IPoolManager.ModifyLiquidityParams calldata,
            bytes calldata
        ) external override returns (bytes4) {
            beforeAddLiquidityCount[key.toId()]++;
            return BaseHook.beforeAddLiquidity.selector;
        }

        function beforeRemoveLiquidity(
            address,
            PoolKey calldata key,
            IPoolManager.ModifyLiquidityParams calldata,
            bytes calldata
        ) external override returns (bytes4) {
            beforeRemoveLiquidityCount[key.toId()]++;
            return BaseHook.beforeRemoveLiquidity.selector;
        }
    }
  script: |
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.19;

    import "forge-std/Script.sol";
    import {IHooks} from "v4-core/interfaces/IHooks.sol";
    import {Hooks} from "v4-core/libraries/Hooks.sol";
    import {PoolManager} from "v4-core/PoolManager.sol";
    import {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";
    import {PoolModifyLiquidityTest} from "v4-core/test/PoolModifyLiquidityTest.sol";
    import {PoolSwapTest} from "v4-core/test/PoolSwapTest.sol";
    import {PoolDonateTest} from "v4-core/test/PoolDonateTest.sol";
    import {PoolKey} from "v4-core/types/PoolKey.sol";
    import {MockERC20} from "solmate/src/test/utils/mocks/MockERC20.sol";
    import {Constants} from "lib/v4-core/test/utils/Constants.sol";
    import {TickMath} from "v4-core/libraries/TickMath.sol";
    import {CurrencyLibrary, Currency} from "v4-core/types/Currency.sol";
    import {Counter} from "src/Counter.sol";
    import {HookMiner} from "test/Counter.t.sol";

    /// @notice Forge script for deploying v4 & hooks to **anvil**
    /// @dev This script only works on an anvil RPC because v4 exceeds bytecode limits
    contract CounterScript is Script {
        address constant CREATE2_DEPLOYER = address(0x4e59b44847b379578588920cA78FbF26c0B4956C);

        function setUp() public {}

        function run() public {
            vm.broadcast();
            IPoolManager manager = deployPoolManager();

            // hook contracts must have specific flags encoded in the address
            uint160 permissions = uint160(
                Hooks.BEFORE_SWAP_FLAG | Hooks.AFTER_SWAP_FLAG | Hooks.BEFORE_ADD_LIQUIDITY_FLAG
                    | Hooks.BEFORE_REMOVE_LIQUIDITY_FLAG
            );

            // Mine a salt that will produce a hook address with the correct permissions
            (address hookAddress, bytes32 salt) =
                HookMiner.find(CREATE2_DEPLOYER, permissions, type(Counter).creationCode, abi.encode(address(manager)));

            // ----------------------------- //
            // Deploy the hook using CREATE2 //
            // ----------------------------- //
            vm.broadcast();
            Counter counter = new Counter{salt: salt}(manager);
            require(address(counter) == hookAddress, "CounterScript: hook address mismatch");

            // Additional helpers for interacting with the pool
            vm.startBroadcast();
            (PoolModifyLiquidityTest lpRouter, PoolSwapTest swapRouter,) = deployRouters(manager);
            vm.stopBroadcast();

            // test the lifecycle (create pool, add liquidity, swap)
            vm.startBroadcast();
            testLifecycle(manager, address(counter), lpRouter, swapRouter);
            vm.stopBroadcast();
        }

        // -----------------------------------------------------------
        // Helpers
        // -----------------------------------------------------------
        function deployPoolManager() internal returns (IPoolManager) {
            return IPoolManager(address(new PoolManager(500000)));
        }

        function deployRouters(IPoolManager manager)
            internal
            returns (PoolModifyLiquidityTest lpRouter, PoolSwapTest swapRouter, PoolDonateTest donateRouter)
        {
            lpRouter = new PoolModifyLiquidityTest(manager);
            swapRouter = new PoolSwapTest(manager);
            donateRouter = new PoolDonateTest(manager);
        }

        function deployTokens() internal returns (MockERC20 token0, MockERC20 token1) {
            MockERC20 tokenA = new MockERC20("MockA", "A", 18);
            MockERC20 tokenB = new MockERC20("MockB", "B", 18);
            if (uint160(address(tokenA)) < uint160(address(tokenB))) {
                token0 = tokenA;
                token1 = tokenB;
            } else {
                token0 = tokenB;
                token1 = tokenA;
            }
        }

        function testLifecycle(
            IPoolManager manager,
            address hook,
            PoolModifyLiquidityTest lpRouter,
            PoolSwapTest swapRouter
        ) internal {
            (MockERC20 token0, MockERC20 token1) = deployTokens();
            token0.mint(msg.sender, 100_000 ether);
            token1.mint(msg.sender, 100_000 ether);

            bytes memory ZERO_BYTES = new bytes(0);

            // initialize the pool
            int24 tickSpacing = 60;
            PoolKey memory poolKey =
                PoolKey(Currency.wrap(address(token0)), Currency.wrap(address(token1)), 3000, tickSpacing, IHooks(hook));
            manager.initialize(poolKey, Constants.SQRT_PRICE_1_1, ZERO_BYTES);

            // approve the tokens to the routers
            token0.approve(address(lpRouter), type(uint256).max);
            token1.approve(address(lpRouter), type(uint256).max);
            token0.approve(address(swapRouter), type(uint256).max);
            token1.approve(address(swapRouter), type(uint256).max);

            // add full range liquidity to the pool
            lpRouter.modifyLiquidity(
                poolKey,
                IPoolManager.ModifyLiquidityParams(
                    TickMath.minUsableTick(tickSpacing), TickMath.maxUsableTick(tickSpacing), 100 ether, 0
                ),
                ZERO_BYTES
            );

            // swap some tokens
            bool zeroForOne = true;
            int256 amountSpecified = 1 ether;
            IPoolManager.SwapParams memory params = IPoolManager.SwapParams({
                zeroForOne: zeroForOne,
                amountSpecified: amountSpecified,
                sqrtPriceLimitX96: zeroForOne ? TickMath.MIN_SQRT_PRICE + 1 : TickMath.MAX_SQRT_PRICE - 1 // unlimited impact
            });
            PoolSwapTest.TestSettings memory testSettings =
                PoolSwapTest.TestSettings({takeClaims: false, settleUsingBurn: false});
            swapRouter.swap(poolKey, params, testSettings, ZERO_BYTES);
        }
    }
  test: |
    // SPDX-License-Identifier: GPL-2.0-or-later
    pragma solidity ^0.8.21;

    /// @title HookMiner - a library for mining hook addresses
    /// @dev This library is intended for `forge test` environments. There may be gotchas when using salts in `forge script` or `forge create`
    library HookMiner {
        // mask to slice out the bottom 14 bit of the address
        uint160 constant FLAG_MASK = 0x3FFF;

        // Maximum number of iterations to find a salt, avoid infinite loops
        uint256 constant MAX_LOOP = 100_000;

        /// @notice Find a salt that produces a hook address with the desired `flags`
        /// @param deployer The address that will deploy the hook. In `forge test`, this will be the test contract `address(this)` or the pranking address
        ///                 In `forge script`, this should be `0x4e59b44847b379578588920cA78FbF26c0B4956C` (CREATE2 Deployer Proxy)
        /// @param flags The desired flags for the hook address
        /// @param creationCode The creation code of a hook contract. Example: `type(Counter).creationCode`
        /// @param constructorArgs The encoded constructor arguments of a hook contract. Example: `abi.encode(address(manager))`
        /// @return hookAddress salt and corresponding address that was found. The salt can be used in `new Hook{salt: salt}(<constructor arguments>)`
        function find(address deployer, uint160 flags, bytes memory creationCode, bytes memory constructorArgs)
            internal
            view
            returns (address, bytes32)
        {
            address hookAddress;
            bytes memory creationCodeWithArgs = abi.encodePacked(creationCode, constructorArgs);

            uint256 salt;
            for (salt; salt < MAX_LOOP; salt++) {
                hookAddress = computeAddress(deployer, salt, creationCodeWithArgs);
                if (uint160(hookAddress) & FLAG_MASK == flags && hookAddress.code.length == 0) {
                    return (hookAddress, bytes32(salt));
                }
            }
            revert("HookMiner: could not find salt");
        }

        /// @notice Precompute a contract address deployed via CREATE2
        /// @param deployer The address that will deploy the hook. In `forge test`, this will be the test contract `address(this)` or the pranking address
        ///                 In `forge script`, this should be `0x4e59b44847b379578588920cA78FbF26c0B4956C` (CREATE2 Deployer Proxy)
        /// @param salt The salt used to deploy the hook
        /// @param creationCode The creation code of a hook contract
        function computeAddress(address deployer, uint256 salt, bytes memory creationCode)
            internal
            pure
            returns (address hookAddress)
        {
            return address(
                uint160(uint256(keccak256(abi.encodePacked(bytes1(0xFF), deployer, salt, keccak256(creationCode)))))
            );
        }
    }
  foundryConfig : |
    [rpc_endpoints]
    mainnet = "https://eth.llamarpc.com"
    [profile.default]
    src = "src"
    out = "out"
    libs = ["lib"]
    ffi = true
    fs_permissions = [{ access = "read-write", path = ".forge-snapshots/"}]
    solc_version = "0.8.26"
    evm_version = "cancun"
    eth_rpc_url = "https://eth.llamarpc.com"